package main

import "strconv"

// TODO: Implementation is so fucking stupid. Write a better one

var huffmanCodes = map[rune]string{
	'/':  "011000",
	'0':  "00000",
	'1':  "00001",
	'2':  "00010",
	'3':  "011001",
	'4':  "011010",
	'5':  "011011",
	'6':  "011100",
	'7':  "011101",
	'8':  "011110",
	'9':  "011111",
	':':  "1011100",
	';':  "11111011",
	'<':  "111111111111100",
	'=':  "100000",
	'>':  "111111111011",
	'?':  "1111111100",
	'@':  "1111111111010",
	'A':  "100001",
	'B':  "1011101",
	'C':  "1011110",
	'D':  "1011111",
	'E':  "1100000",
	'F':  "1100001",
	'G':  "1100010",
	'H':  "1100011",
	'I':  "1100100",
	'J':  "1100101",
	'K':  "1100110",
	'L':  "1100111",
	'M':  "1101000",
	'N':  "1101001",
	'O':  "1101010",
	'P':  "1101011",
	'Q':  "1101100",
	'R':  "1101101",
	'S':  "1101110",
	'T':  "1101111",
	'U':  "1110000",
	'V':  "1110001",
	'W':  "1110010",
	'X':  "11111100",
	'Y':  "1110011",
	'Z':  "11111101",
	'[':  "1111111111011",
	'\\': "1111111111111110|000",
	']':  "1111111111100",
	'^':  "11111111111100",
	'_':  "100010",
	'`':  "11111111|1111101",
	'a':  "00011",
	'b':  "100011",
	'c':  "00100",
	'd':  "100100",
	'e':  "00101",
	'f':  "100101",
	'g':  "100110",
	'h':  "100111",
	'i':  "00110",
	'.':  "010111",
	'j':  "1110100",
	'k':  "1110101",
	'l':  "101000",
	'm':  "101001",
	'n':  "101010",
	'o':  "00111",
	'p':  "101011",
	'q':  "1110110",
	'r':  "101100",
	's':  "01000",
	't':  "01001",
	'u':  "101101",
	'v':  "1110111",
	'w':  "1111000",
	'x':  "1111001",
	'y':  "1111010",
	'z':  "1111011",
	'{':  "111111111111110",
	'|':  "11111111100",
	'}':  "11111111111101",
	'~':  "1111111111101",
}

func HuffmanEncode(s string) []byte {
	seq := ""
	for _, char := range s {
		binStr, found := huffmanCodes[char]
		if !found {
			binStr = strconv.FormatInt(int64(char), 2)
		}
		seq += binStr
	}

	paddingLength := (8 - (len(seq) % 8)) % 8
	padding := ""
	for i := 0; i < paddingLength; i++ {
		padding += "1"
	}
	seq += padding

	b := []byte{}
	for i := 0; i < len(seq); i += 8 {
		var n uint64 = 0
		for j := 0; j < 8; j++ {
			if seq[i+j] == '1' {
				n += pow(2, uint8(7-j))
			}
		}

		b = append(b, uint8(n))
	}

	return b
}

var huffmanDecodeCodes = map[string]rune{
	"011000":               '/',
	"00000":                '0',
	"00001":                '1',
	"00010":                '2',
	"011001":               '3',
	"011010":               '4',
	"011011":               '5',
	"011100":               '6',
	"011101":               '7',
	"011110":               '8',
	"011111":               '9',
	"1011100":              ':',
	"11111011":             ';',
	"111111111111100":      '<',
	"100000":               '=',
	"111111111011":         '>',
	"1111111100":           '?',
	"1111111111010":        '@',
	"100001":               'A',
	"1011101":              'B',
	"1011110":              'C',
	"1011111":              'D',
	"1100000":              'E',
	"1100001":              'F',
	"1100010":              'G',
	"1100011":              'H',
	"1100100":              'I',
	"1100101":              'J',
	"1100110":              'K',
	"1100111":              'L',
	"1101000":              'M',
	"1101001":              'N',
	"1101010":              'O',
	"1101011":              'P',
	"1101100":              'Q',
	"1101101":              'R',
	"1101110":              'S',
	"1101111":              'T',
	"1110000":              'U',
	"1110001":              'V',
	"1110010":              'W',
	"11111100":             'X',
	"1110011":              'Y',
	"11111101":             'Z',
	"1111111111011":        '[',
	"1111111111111110|000": '\\',
	"1111111111100":        ']',
	"11111111111100":       '^',
	"100010":               '_',
	"11111111|1111101":     '`',
	"00011":                'a',
	"100011":               'b',
	"00100":                'c',
	"100100":               'd',
	"00101":                'e',
	"100101":               'f',
	"100110":               'g',
	"100111":               'h',
	"00110":                'i',
	"010111":               '.',
	"1110100":              'j',
	"1110101":              'k',
	"101000":               'l',
	"101001":               'm',
	"101010":               'n',
	"00111":                'o',
	"101011":               'p',
	"1110110":              'q',
	"101100":               'r',
	"01000":                's',
	"01001":                't',
	"101101":               'u',
	"1110111":              'v',
	"1111000":              'w',
	"1111001":              'x',
	"1111010":              'y',
	"1111011":              'z',
	"111111111111110":      '{',
	"11111111100":          '|',
	"11111111111101":       '}',
	"1111111111101":        '~',
}

func HuffmanDecode(b []byte) string {
	binaryRepr := ""
	for _, c := range b {
		for i := 7; i >= 0; i-- {
			binaryRepr += string(((c >> i) & 0x1) + 48) // 48 = '0'
		}
	}

	tmp := ""
	decodedStr := ""
	for _, c := range binaryRepr {
		tmp += string(c)
		if char, found := huffmanDecodeCodes[tmp]; found {
			decodedStr += string(char)
			tmp = ""
		}
	}

	return decodedStr
}
